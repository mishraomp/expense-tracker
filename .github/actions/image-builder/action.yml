name: Conditional Container Builder with Fallback
description: Build if trigger conditions are met, else use fallback image
branding:
  icon: package
  color: blue

inputs:
  ### Required
  package:
    description: Package name; e.g. backend, frontend
    required: true

  ### Typical / recommended
  build_context:
    description: Build context, not required for self-contained package/default directory
  build_file:
    description: Dockerfile with path, not required for self-contained package/default directory
  sbom:
    default: "true"
    description: Generate a Software Bill of Materials (SBOM) for the container image. Enabled by default for better security practices.
  tag_fallback:
    description: Where to pull default images from; e.g. prod, test
  tags:
    default: ${{ github.event.number }}
    description: |
      Default tag(s); e.g. pr#, test, prod.
      Supports multiline input for multiple tags.
      Example: |
        pr123
        demo
        test
  triggers:
    description: Paths used to trigger a build; e.g. ('./backend/' './frontend/)

  ### Usually a bad idea / not recommended
  build_args:
    description: A list of build-time variables, generally not advisable
    default: "BUILDKIT_INLINE_CACHE=1"
  diff_branch:
    description: Branch to diff against
    default: ${{ github.event.repository.default_branch }}
  repository:
    description: Non-default repo to clone
    default: ${{ github.repository }}
  tag:
    description: Deprecated input; use tags instead
    deprecationMessage: "Input 'tag' is deprecated and will be removed in a future release. Please use 'tags' instead."
  token:
    description: Specify token (GH or PAT), instead of inheriting one from the calling workflow
    default: ${{ github.token }}
  secrets:
    description: |
      Multiline input for secrets to mount.
      https://docs.docker.com/build/ci/github-actions/secrets/#secret-mounts
      Example: |
        MY_SECRET=secret_value
        ANOTHER_SECRET=another_value
  metadata_tags:
    default: "false"
    description: |
      Enable automatic tag and label generation using docker/metadata-action based on user-provided tag rules.
      When enabled, generates tags and labels according to the rules specified in 'metadata_tag_rules'.
      String value, not boolean. Set to 'true' to enable.
  metadata_flavor:
    description: |
      Flavor configuration for metadata-action (e.g., 'latest=true').
      Only used when metadata_tags is enabled.
      See: https://github.com/docker/metadata-action#flavor-input
  metadata_tag_rules:
    description: |
      Custom tag rules for metadata-action.
      Only used when metadata_tags is enabled.
      Example: |
        type=ref,event=branch
        type=semver,pattern={{version}}
      See: https://github.com/docker/metadata-action#tags-input

outputs:
  digest:
    description: "Digest of the built image; e.g. sha256:1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    value: ${{ steps.build_and_push.outputs.digest }}

  triggered:
    description: Did a deployment trigger?  [true|false]
    value: ${{ steps.diff.outputs.triggered }}

  labels:
    description: "Generated OCI labels from metadata-action (only when metadata_tags is enabled)"
    value: ${{ steps.tags.outputs.labels }}

  annotations:
    description: "Generated OCI annotations from metadata-action (only when metadata_tags is enabled)"
    value: ${{ steps.tags.outputs.annotations }}

runs:
  using: composite
  steps:
    - id: vars
      shell: bash
      env:
        INPUT_PACKAGE: ${{ inputs.package }}
        CONTEXT_REPO: ${{ github.event.repository.name }}
        INPUT_TAGS: ${{ inputs.tags }}
      run: |
        # Process inputs and set variables
        set -euo pipefail

        # Early exit for deprecated input
        if [ -n "${{ inputs.tag }}" ]; then
          echo "Input 'tag' is deprecated. Please use 'tags' instead."
          exit 1
        fi

        # If package matches repo name, use simpler image_path
        if [ "${INPUT_PACKAGE,,}" = "${CONTEXT_REPO,,}" ]; then
          image_path="${{ github.repository }}"
        else
          image_path="${{ github.repository }}/${{ inputs.package }}"
        fi
        echo "image_path=${image_path,,}" >> $GITHUB_OUTPUT
        echo "image_name=ghcr.io/${image_path,,}" >> $GITHUB_OUTPUT

        # Filter out empty lines from tags input (used for both metadata_tags and first_tag)
        filtered_tags=$(printf '%s\n' "${INPUT_TAGS}" | grep -v '^$' || true)

        # Convert multiline tags to metadata-action format (type=raw,value=tag)
        # Each line becomes: type=raw,value=<tag>
        if [ -n "${filtered_tags}" ]; then
          metadata_tags=$(printf '%s\n' "${filtered_tags}" | tr '[:upper:]' '[:lower:]' | sed 's/^/type=raw,value=/')
          echo "metadata_tags<<EOF" >> $GITHUB_OUTPUT
          echo "${metadata_tags}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        fi

        # Extract first tag for artifact naming (sanitized for artifact name compatibility)
        # Artifact names can contain: letters, numbers, hyphens, underscores, and periods
        if [ -n "${filtered_tags}" ]; then
          first_tag=$(printf '%s\n' "${filtered_tags}" | head -n 1 | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]._-')
        fi
        # Fallback to 'artifact' if sanitized tag is empty
        first_tag="${first_tag:-artifact}"
        echo "first_tag=${first_tag}" >> $GITHUB_OUTPUT

    # Send triggers to diff action
    - id: diff
      uses: bcgov/action-diff-triggers@0d193029efd26c76aeacaa84aba3328de8198370 # v0.2.0
      with:
        triggers: ${{ inputs.triggers }}
        diff_branch: ${{ inputs.diff_branch }}

    # Check if a build is required (steps.build.outputs.triggered=true|false)
    - name: Check for builds
      env:
        URL_FALLBACK: ghcr.io/${{ steps.vars.outputs.image_path }}:${{ inputs.tag_fallback }}
      id: build
      shell: bash
      run: |
        # Check for builds
        triggered=true
        if [ "${{ steps.diff.outputs.triggered }}" == "true" ]; then
          echo "Build triggered. Used bcgov/action-diff-triggers."
        elif [ "${{ inputs.repository }}" != "${{ github.repository }}" ]; then
          echo "Build triggered.  Override repository provided."
        elif [ -z "${{ inputs.tag_fallback }}" ]; then
          echo "Build triggered.  No tag_fallback provided."
        elif [[ ! $(docker manifest inspect "${URL_FALLBACK}") ]]; then
          echo "Build triggered.  Fallback tag (tag_fallback) not usable."
        else
          echo "Container build not required"
          triggered=false
        fi
        echo "triggered=$triggered" >> $GITHUB_OUTPUT

    # If a build is not required, reuse a previous image
    - name: Recycle/retag Previous Images
      uses: shrink/actions-docker-registry-tag@f04afd0559f66b288586792eb150f45136a927fa # v4
      if: steps.build.outputs.triggered != 'true'
      with:
        registry: ghcr.io
        repository: ${{ steps.vars.outputs.image_path }}
        target: ${{ inputs.tag_fallback }}
        tags: |
          ${{ inputs.tags }}

    - uses: actions/checkout@v6
      with:
        repository: ${{ inputs.repository }}

    - name: Set up Docker Buildx
      if: steps.build.outputs.triggered == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to the Container registry
      if: steps.build.outputs.triggered == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ inputs.token }}

    - name: Prepare Container Metadata tags
      id: meta
      if: steps.build.outputs.triggered == 'true' && inputs.metadata_tags == 'true'
      uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
      with:
        images: ${{ steps.vars.outputs.image_name }}
        flavor: ${{ inputs.metadata_flavor }}
        tags: ${{ inputs.metadata_tag_rules }}

    - name: Merge tags
      id: tags
      if: steps.build.outputs.triggered == 'true'
      shell: bash
      env:
        INPUT_TAGS: ${{ inputs.tags }}
        META_TAGS: ${{ steps.meta.outputs.tags || '' }}
        META_LABELS: ${{ steps.meta.outputs.labels || '' }}
        META_ANNOTATIONS: ${{ steps.meta.outputs.annotations || '' }}
      run: |
        # Merge metadata tags with custom tags
        set -euo pipefail

        # Start with custom tags (convert from multiline to comma-separated)
        # Handle empty inputs gracefully
        custom_tags=""
        if [ -n "${INPUT_TAGS}" ]; then
          # Filter out empty lines and process tags; use printf to safely handle multiline input
          filtered_tags=$(printf '%s\n' "${INPUT_TAGS}" | grep -v '^$' || true)
          if [ -n "${filtered_tags}" ]; then
            custom_tags=$(printf '%s\n' "${filtered_tags}" | sed "s|^|ghcr.io/${{ steps.vars.outputs.image_path }}:|" | tr '[:upper:]' '[:lower:]' | paste -sd,)
          fi
        fi

        # If metadata tags are enabled, merge them
        if [ "${{ inputs.metadata_tags }}" == "true" ]; then
          # Convert metadata tags from newline-separated to comma-separated (if any)
          # Use printf to safely handle multiline output from metadata-action
          meta_tags=""
          if [ -n "${META_TAGS}" ]; then
            meta_tags=$(printf '%s\n' "${META_TAGS}" | tr '\n' ',' | sed 's/,$//')
          fi
          
          # Combine tags (prefer custom tags first, then metadata tags)
          if [ -n "${custom_tags}" ] && [ -n "${meta_tags}" ]; then
            final_tags="${custom_tags},${meta_tags}"
          elif [ -n "${meta_tags}" ]; then
            final_tags="${meta_tags}"
          else
            final_tags="${custom_tags}"
          fi
          
          # Pass through labels and annotations from metadata-action (even if no tags were generated)
          # Use heredoc to safely handle multiline/special characters
          echo "labels<<EOF" >> $GITHUB_OUTPUT
          echo "${META_LABELS}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "annotations<<EOF" >> $GITHUB_OUTPUT
          echo "${META_ANNOTATIONS}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          final_tags="${custom_tags}"
          # Empty labels and annotations when metadata_tags is disabled
          echo "labels=" >> $GITHUB_OUTPUT
          echo "annotations=" >> $GITHUB_OUTPUT
        fi

        # Ensure at least one tag is present; fallback to :latest if empty
        if [ -z "${final_tags}" ]; then
          # Warn if metadata_tags is enabled but no tags were generated (likely configuration error)
          if [ "${{ inputs.metadata_tags }}" == "true" ]; then
            echo "::warning::metadata_tags is enabled but no tags were generated. This may indicate missing or invalid metadata_tag_rules. Falling back to :latest tag."
          fi
          final_tags="ghcr.io/${{ steps.vars.outputs.image_path }}:latest"
        fi

        echo "final_tags=${final_tags}" >> $GITHUB_OUTPUT

    - name: Build and push ${{ inputs.package }} Docker image
      id: build_and_push
      if: steps.build.outputs.triggered == 'true'
      uses: docker/build-push-action@v6
      with:
        context: ${{ inputs.build_context || inputs.package }}
        file: ${{ inputs.build_file || format('{0}/Dockerfile', inputs.package) }}
        push: true
        tags: ${{ steps.tags.outputs.final_tags }}
        labels: ${{ steps.tags.outputs.labels }}
        annotations: ${{ steps.tags.outputs.annotations }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: ${{ inputs.build_args }}
        secrets: ${{ inputs.secrets }}

    - name: Install Syft
      if: steps.build.outputs.triggered == 'true' && inputs.sbom == 'true'
      shell: bash
      run: |
        # Install Syft
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

    - name: Generate SBOM
      id: sbom
      if: steps.build.outputs.triggered == 'true' && inputs.sbom == 'true'
      continue-on-error: true
      shell: bash
      run: |
        set +e -u

        IMAGE="ghcr.io/${{ steps.vars.outputs.image_path }}@${{ steps.build_and_push.outputs.digest }}"
        PACKAGE_SANITIZED=$(echo "${{ inputs.package }}" | tr '/:' '-' | tr -d ' ')
        echo "package_sanitized=${PACKAGE_SANITIZED}" >> $GITHUB_OUTPUT

        mkdir -p sboms

        # Check image accessibility
        if ! docker manifest inspect "$IMAGE" >/dev/null 2>&1; then
          echo "::warning::Cannot access image $IMAGE. SBOM generation will be skipped."
          echo "sbom_files_exist=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Generate both formats in a single scan
        CYCLONEDX_FILE="sboms/${PACKAGE_SANITIZED}-cyclonedx.json"
        SPDX_FILE="sboms/${PACKAGE_SANITIZED}-spdx.json"
        stderr_file=$(mktemp)

        syft scan "$IMAGE" \
          -o cyclonedx-json="$CYCLONEDX_FILE" \
          -o spdx-json="$SPDX_FILE" \
          2>"$stderr_file"

        exit_code=$?
        stderr=$(cat "$stderr_file")
        rm -f "$stderr_file"

        if [ $exit_code -eq 0 ]; then
          if [ -n "$stderr" ]; then
            echo "::notice::Syft warnings: ${stderr}"
          fi
          echo "✓ SBOMs generated successfully (CycloneDX and SPDX)"
          echo "sbom_files_exist=true" >> $GITHUB_OUTPUT
        else
          error_msg=$(echo "$stderr" | head -c 500)
          echo "::warning::SBOM generation failed: ${error_msg}"
          rm -f "$CYCLONEDX_FILE" "$SPDX_FILE"
          echo "sbom_files_exist=false" >> $GITHUB_OUTPUT
          echo "::warning::No SBOM files were generated. Workflow will continue without SBOM artifacts."
        fi

    - name: Upload SBOMs
      uses: actions/upload-artifact@v6
      if: steps.build.outputs.triggered == 'true' && inputs.sbom == 'true' && steps.sbom.outputs.sbom_files_exist == 'true'
      continue-on-error: true
      with:
        name: sboms-${{ steps.sbom.outputs.package_sanitized }}-${{ steps.vars.outputs.first_tag }}
        path: sboms/
        if-no-files-found: warn

    - name: Attest
      continue-on-error: true
      id: attest
      if: steps.build.outputs.triggered == 'true'
      uses: actions/attest-build-provenance@v3.1.0
      with:
        subject-name: ghcr.io/${{ steps.vars.outputs.image_path }}
        subject-digest: ${{ steps.build_and_push.outputs.digest }}

    - name: Verify attestations
      if: steps.build.outputs.triggered == 'true'
      continue-on-error: true
      shell: bash
      run: |
        echo "::notice::Verifying build attestations..."

        # Verify GitHub attestation
        if [ "${{ steps.attest.outcome }}" = "success" ]; then
          echo "✓ GitHub build provenance attestation verified"
        else
          echo "⚠ GitHub build provenance attestation failed"
        fi

        # Verify SBOM files exist (only if SBOM was enabled)
        if [ "${{ inputs.sbom }}" = "true" ]; then
          if [ "${{ steps.sbom.outputs.sbom_files_exist }}" = "true" ]; then
            echo "✓ SBOM files generated successfully"
            echo "  - CycloneDX: sboms/${{ steps.sbom.outputs.package_sanitized }}-cyclonedx.json"
            echo "  - SPDX: sboms/${{ steps.sbom.outputs.package_sanitized }}-spdx.json"
          else
            echo "⚠ SBOM generation failed"
          fi
        fi

        echo "::notice::Attestation verification completed"

    - name: Prompt user to fix permissions
      if: steps.attest.outcome == 'failure'
      shell: bash
      run: |
        echo "::warning::Attestation skipped due to missing id-token:write and attestations:write permissions. Please update workflow permissions."

    # Action repo needs to be present for cleanup/tests
    - name: Checkout local repo to make sure action.yml is present
      if: github.repository != inputs.repository || failure()
      uses: actions/checkout@v6

    - name: Print summary outputs
      if: always() # Always run this step to summarize the build
      shell: bash
      run: |
        echo "---- Build Summary ----"
        echo "digest: ${{ steps.build_and_push.outputs.digest }}"
        echo "triggered: ${{ steps.diff.outputs.triggered }}"
        echo "final_tags: ${{ steps.tags.outputs.final_tags }}"
        echo "metadata_enabled: ${{ inputs.metadata_tags }}"
        if [ "${{ inputs.metadata_tags }}" == "true" ]; then
          echo "metadata_labels: ${{ steps.tags.outputs.labels }}"
          echo "metadata_annotations: ${{ steps.tags.outputs.annotations }}"
        fi
        echo "-----------------------"