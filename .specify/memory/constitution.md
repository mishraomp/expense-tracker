<!--
Sync Impact Report
Version: 1.0.0 -> 1.1.0
Modified Principles: 
 - I. Code Quality & Maintainability → Enhanced with tech-stack specifics (TypeScript, NestJS, React, Vite, Prisma, Keycloak)
 - II. Test Discipline & Coverage → Updated with Vitest + Playwright specifics
 - III. UX Consistency & Accessibility → Enhanced with Bootstrap, TanStack, D3 patterns
 - IV. Performance & Efficiency → Added Vite build budgets, TanStack Query optimization
Added Sections: None (structure preserved)
Removed Sections: None
Templates Alignment (re-verified):
 - .specify/templates/plan-template.md ✅ (references Performance Goals & Constraints; aligns with Principles IV & I)
 - .specify/templates/spec-template.md ✅ (user stories + acceptance enable Principle II test discipline & Principle III UX)
 - .specify/templates/tasks-template.md ✅ (Polish phase performance optimization cites Principle IV, add implicit linkage)
Deferred TODOs: None
Compliance Follow-up: First monthly audit due 2025-12-22; Next audit 2026-01-22
-->

# Expense Tracker Project Constitution

## Core Principles

### I. Code Quality & Maintainability
All committed code MUST be: (a) statically typed (TypeScript strict mode enforced in both `backend/tsconfig.json` and `frontend/tsconfig.json`; explicit return types required for all exported functions and public methods), (b) free of ESLint errors and Prettier formatting deviations (enforced via `backend/eslint.config.js` and `frontend/eslint.config.js`), (c) organized into cohesive NestJS modules (backend) or feature-based directories (frontend) with clear interfaces and zero cyclic dependencies (verified via build-time checks), (d) free of unused/dead code within 2 subsequent PRs (checked via ESLint `no-unused-vars` and IDE analysis), (e) secure by construction: Prisma parameterized queries only (no raw SQL), no secrets in source code, input validation using `class-validator` DTOs on all NestJS endpoints and React Hook Form validators on frontend forms, Keycloak JWT authentication enforced on protected routes, (f) documented: JSDoc comments required for all public NestJS service methods and exported React hooks/utilities (purpose + parameter constraints + return type). Backend modules MUST export only necessary providers; frontend components MUST use PropTypes or TypeScript interfaces. Complexity thresholds: cyclomatic complexity > 10 triggers mandatory refactor before merge unless justified in PR description with ADR reference. Rationale: Explicit tech-stack constraints reduce ambiguity, improve onboarding velocity, and ensure consistency across a polyglot (NestJS + React + Vite) stack.

### II. Test Discipline & Coverage
Test creation precedes implementation for all new P1 endpoints and services (TDD: write failing Vitest tests first). Testing strategy: (a) Backend unit tests via Vitest (`backend/vitest.config.ts`), contract tests in `backend/tests/contract/` for API endpoint validation (HTTP status codes, response schemas), integration tests hitting test Postgres schema with transactional rollbacks, (b) Frontend unit tests via Vitest + Testing Library (`frontend/vitest.config.ts`, `frontend/tests/setup.ts`) for components, hooks, utilities; Playwright E2E tests (`frontend/tests/e2e/`) REQUIRED for P1 user journeys (authentication, expense CRUD, report drill-down), OPTIONAL for P2/P3 features. Minimum coverage gates enforced in CI: backend lines ≥ 85%, branches ≥ 75%; frontend critical logic (TanStack Query hooks, auth store, form validators) lines ≥ 80%. Each bug fix MUST add at least one regression test (unit or E2E depending on layer). External integrations (Keycloak token validation, future APIs) MUST be isolated via mocks (`vi.mock()` for Vitest) in unit tests; integration tests only for service-to-DB or service-to-Keycloak boundary contracts. Builds FAIL if coverage drops below thresholds, if any test is flaky (≥2 non-deterministic failures in last 20 runs), or if E2E tests timeout (max 30s per test). Rationale: Tool-specific test discipline (Vitest for speed, Playwright for real browser validation) ensures predictable delivery pace and safe refactors in a full-stack TypeScript environment.

### III. UX Consistency & Accessibility
UI components MUST use shared design tokens and centralized state patterns: (a) Styling: Bootstrap 5 utility classes + custom Sass variables in `frontend/src/styles/theme.scss` (colors, spacing, typography); no ad hoc inline styles except dynamic D3 chart attributes or runtime-computed dimensions, (b) State management: TanStack Query for server state (expenses, incomes, categories) with centralized `queryClient` (`frontend/src/services/queryClient.ts`); Zustand store for auth state (`frontend/src/stores/auth.ts`); React Hook Form for form state, (c) Routing: TanStack Router with type-safe route definitions (`frontend/src/routes/`). Interactive elements MUST provide consistent loading states: TanStack Query `isLoading`/`isFetching` triggers skeleton or spinner within 300ms; error boundaries or `error` states display actionable messages (plain language + retry button or next step). All new UI flows MUST meet WCAG AA: color contrast ≥ 4.5:1 (verify via browser DevTools or Lighthouse), keyboard-only navigation (tab order logical, `Enter`/`Space` activate buttons/links, modals trap focus), visible focus indicators (`:focus-visible` styles in Sass). User-visible text MUST avoid jargon (e.g., "Sign in" not "Authenticate"). Navigation and layout patterns MUST reuse existing `frontend/src/components/layout/` components (Header, Sidebar, Footer); introducing a new layout component requires ADR with rationale. Chart accessibility: D3 visualizations MUST include `<title>`, `<desc>`, and ARIA labels; provide accessible data tables as fallback or export. Rationale: Leveraging Bootstrap, TanStack, and D3 conventions ensures consistent, accessible UX patterns while minimizing per-component boilerplate.

### IV. Performance & Efficiency
Performance budgets and optimization requirements: (a) Backend (NestJS): API read endpoints (GET `/api/expenses`, `/api/reports/*`) p95 latency < 400ms; write endpoints (POST/PUT/DELETE) p95 < 800ms; background jobs (CSV import processing) complete within SLA per spec (default < 5s for standard ingestion tasks). Database queries via Prisma MUST avoid N+1 (detected via query logs or `prisma.$queryRawUnsafe` analysis) and use appropriate indexes (verify via `EXPLAIN` for complex filters/sorts). No polling intervals < 30s unless justified by real-time requirement (prefer WebSocket or Server-Sent Events for live updates). (b) Frontend (Vite + React): Initial bundle (JS + CSS) MUST remain < 250KB gzipped post-build (`npm run build` in `frontend/`); route-level code splitting (`React.lazy()` + TanStack Router lazy loading) required for additions exceeding 30KB; Vite build analyzer (`vite-plugin-visualizer`) MUST be consulted before merging bundle-size PRs. Time-to-interactive (TTI) on mid-tier hardware (Chrome, 4GB RAM, throttled 4G) MUST be < 2.0s for primary dashboard (`/expenses`, `/reports`) and < 2.5s for secondary views (`/import`, `/incomes`). TanStack Query stale-time and cache-time tuned per resource (e.g., categories: `staleTime: 5min`, expenses: `staleTime: 30s`). D3 chart rendering (Income vs Expense bar, Subcategory pie) MUST complete initial render in < 500ms for datasets up to 1000 points; virtualization or pagination required beyond. (c) Memory: Memory usage growth > 10% over baseline in a PR MUST be investigated (Chrome DevTools heap snapshot comparison for frontend, Node.js `--inspect` + heap profiler for backend). Rationale: Vite's fast HMR and TanStack's intelligent caching provide foundational speed; explicit budgets prevent regressions as features scale.

## Quality Gates & Metrics
Quality gates applied at PR merge time: (1) Lint/format pass (ESLint + Prettier for both backend and frontend), (2) Test coverage thresholds (Principle II: backend ≥85% lines, ≥75% branches; frontend critical logic ≥80%), (3) Performance regression guard—any p95 increase > 10% on modified endpoints (benchmarked locally via `autocannon` or `k6`, or via CI synthetic tests) MUST be addressed, (4) Bundle size delta reported (Vite build output + `vite-plugin-visualizer`); exceedances require mitigation plan (code splitting, lazy loading, dependency audit), (5) Accessibility spot check for new UI components (contrast via DevTools, keyboard nav manual test, focus indicators visible). Metrics stored in CI artifact for audit.

## Workflow & Review Process
Workflow phases per feature: Spec → Plan → Tasks → Implementation → Review → Merge. Every PR description MUST map changed files to affected principles (e.g., "Principle II: new Vitest tests for expense validation service"). Reviewers MUST reject PRs lacking: test coverage updates (when logic added), performance consideration for data-heavy queries (Prisma `include` depth, pagination), or UX rationale for new components (Bootstrap pattern reuse justification). Pre-merge checklist: (a) All gates green (lint, tests, coverage, performance, accessibility), (b) No TODO markers without linked GitHub issue, (c) Migration scripts idempotent (Prisma migration files versioned, rollback notes in PR), (d) Security scan (dependency vulnerabilities CVSS ≥ 7.0 blocked; run `npm audit` in both backend and frontend; Prisma queries audited for injection risk). Versioning: Semantic version for constitution (see Governance). ADR required for any exception (e.g., deliberate performance budget exceedance for spike/prototype). Monthly quality audit rotates among maintainers; findings produce backlog tasks within 5 days.

## Governance
This Constitution supersedes informal practices. Amendments: Proposal PR MUST include (a) motivation, (b) impact analysis (which principles/sections affected), (c) version bump justification (MAJOR/MINOR/PATCH per semver), (d) migration or mitigation steps if removing/changing a principle. Versioning policy: MAJOR for removal or fundamental redefining of a principle; MINOR for adding a new principle or expanding measurable scope (e.g., new tech-stack constraints, new quality gate); PATCH for clarifications without changing enforcement semantics (typo fixes, wording improvements). Compliance audits monthly; non-compliance items tracked with priority based on risk (security > performance > UX > maintainability). Emergency exceptions (e.g., hotfix) allowed only if logged in an ADR within 24h. All feature plans must reference Performance Goals & Constraints consistent with Principle IV; Constitution Check section in plan MUST reflect any new metrics introduced here. Constitution amendments trigger updates to dependent templates (plan-template.md, spec-template.md, tasks-template.md) and agent files (.github/agents/*.agent.md) within same PR or follow-up PR within 3 days.

**Version**: 1.1.0 | **Ratified**: 2025-11-22 | **Last Amended**: 2025-11-22
